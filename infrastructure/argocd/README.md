# ArgoCD Manifests

ArgoCD manifests for the pipeline

if you are running in minikube, run
`minikube start --vm-driver=hyperkit`

create namespace 'argocd' in minikube
`kubectl create namespace argocd`

Run the following command to install ArgoCD

e.g. If you are inside the argocd repo, just run
`kubectl apply -n argocd -f ./argo-cd/install.yaml`

(Can check the status by running `kubectl -n argocd get pods`)

controller looks after all the app yamls we passed in.

If something is running in port 8080
`sudo lsof -i :8080`
`kill -9 [process id]`

Run the following command to fast forward to localhost
`kubectl port-forward svc/argocd-server -n argocd 8080:443`

Run the following command to obtain the initial admin password for ArgoCD.
(When logging into the ArgoCD server, the initial id is set to '`admin`')

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo`

Run the following command to deploy application, or just create one in the ArgoCD UI.
e.g. `kubectl apply -n argocd -f ./infrastructure/argocd/argo-cd/app.yaml`


# Trigger argocd to deploy k8s with jenkins pipeline

Install ArgoCD CLI first.

Add role in the argoCD.
How? gear icon -> projects -> default

Made a shell script to login through argocd cli for convenience. Run `./argocd_pwd.bash` to login to the server via argocd cli.


`$ argocd proj role create-token default {name you specified in argocd}`

Add above output token to Jenkin's gloabl credential 


# ArgoCD CLI
* Synchronize The App (Optional)

For convenience, the argocd CLI can be downloaded directly from the API server. This is useful so that the CLI used in the CI pipeline is always kept in-sync and uses argocd binary that is always compatible with the Argo CD API server.

export ARGOCD_SERVER=argocd.mycompany.com
export ARGOCD_AUTH_TOKEN=<JWT token generated from project>
curl -sSL -o /usr/local/bin/argocd https://${ARGOCD_SERVER}/download/argocd-linux-amd64
argocd app sync guestbook
argocd app wait guestbook


If automated synchronization is configured for the application, this step is unnecessary. 
The controller will automatically detect the new config (fast tracked using a webhook, or polled every 3 minutes), and automatically sync the new manifests.


If we want to use ArgoCD CLI in the Jenkins, ensure that the argocd binary is installed somewhere that is runnable by the Jenkins user. 


## Move it to the /usr/local/bin
`$ sudo mv argocd-linux-amd64 /usr/local/bin/argocd`

## Ensure it is exectutable
`$ sudo chmod 755 /usr/local/bin/argocd`

## Check it works
`$ argocd version`



# Sync the App


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app sync $APP_NAME --force`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app sync test-app --force`


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app wait $APP_NAME --timeout 600`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app wait test-app --timeout 600`


The above simply asks ArgoCD to trigger Kubernetes to deploy the app. Within ArgoCD, this is using the Manifest from the Git repository, that has been updated with Kustomize to use the new image tag. This will then go out and deploy a new version of it, based upon the image generated by Jenkins.


# OPTIONAL

Patching the argocd-server to LoadBalancer
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'`

Patching the argocd-server to NodePort
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'`



#################
# usage in gitea: 
#################
#
# http://{server_name}.{namespace}.svc.cluster.local:{portnumber}/path/to/your/deployment/repo.git
#
# e.g. http://gitea-charts-http.default.svc.cluster.local:3000/haesun/Deployment.git
#


1. fuzzer needs a documentation / openAPI
        &&
2. active server    

* Code pipeline (creating new feature) opens PR for feature branch -> master branch
all the static analysis and etc, if successful, updates/pushes the image

* GitOps pipeline opens PR (new release branch PR -> develop branch)

######################
step:
    specify image: argocd cli
    kubelint runs towards the manifests (Config files)
    `argocd app wait APPNAME` -> deploying into dev cluster

next step:
    specify image: of owasp zap
    after steps johno figuring out
    -> exit status 0: successful, and something is failure
    -> YES: exit pipeline, pipeline send webhook to gitea
    -> NO: break pipeline, `argocd app rollback APPNAME ID [flags]`

######################

Not our demo part

New PR:
dev cluster -> prod cluster
