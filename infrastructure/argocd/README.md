# ArgoCD Manifests

ArgoCD manifests for the pipeline

if you are running in minikube, run
`minikube start --vm-driver=hyperkit`

create namespace 'argocd' in minikube
`kubectl create namespace argocd`

Run the following command to install ArgoCD

e.g. If you are inside the argocd repo, just run
`kubectl apply -n argocd -f ./argo-cd/install.yaml`

(Can check the status by running `kubectl -n argocd get pods`)

controller looks after all the app yamls we passed in.

If something is running in port 8080
`sudo lsof -i :8080`
`kill -9 [process id]`

Run the following command to fast forward to localhost
`kubectl port-forward svc/argocd-server -n argocd 8080:443`

Run the following command to obtain the initial admin password for ArgoCD.
(When logging into the ArgoCD server, the initial id is set to '`admin`')

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo`

Run the following command to deploy application, or just create one in the ArgoCD UI.
e.g. `kubectl apply -n argocd -f ./infrastructure/argocd/argo-cd/app.yaml`


# Trigger argocd to deploy k8s with jenkins pipeline

Install ArgoCD CLI first.

Add role in the argoCD.
How? gear icon -> projects -> default

Made a shell script to login through argocd cli for convenience. Run `./argocd_pwd.bash` to login to the server via argocd cli.


`$ argocd proj role create-token default {name you specified in argocd}`

Add above output token to Jenkin's gloabl credential 


# ArgoCD CLI
* Synchronize The App (Optional)

For convenience, the argocd CLI can be downloaded directly from the API server. This is useful so that the CLI used in the CI pipeline is always kept in-sync and uses argocd binary that is always compatible with the Argo CD API server.

export ARGOCD_SERVER=argocd.mycompany.com
export ARGOCD_AUTH_TOKEN=<JWT token generated from project>
curl -sSL -o /usr/local/bin/argocd https://${ARGOCD_SERVER}/download/argocd-linux-amd64
argocd app sync guestbook
argocd app wait guestbook


If automated synchronization is configured for the application, this step is unnecessary. 
The controller will automatically detect the new config (fast tracked using a webhook, or polled every 3 minutes), and automatically sync the new manifests.


If we want to use ArgoCD CLI in the Jenkins, ensure that the argocd binary is installed somewhere that is runnable by the Jenkins user. 


## Move it to the /usr/local/bin
`$ sudo mv argocd-linux-amd64 /usr/local/bin/argocd`

## Ensure it is exectutable
`$ sudo chmod 755 /usr/local/bin/argocd`

## Check it works
`$ argocd version`



# Sync the App


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app sync $APP_NAME --force`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app sync test-app --force`


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app wait $APP_NAME --timeout 600`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app wait test-app --timeout 600`


The above simply asks ArgoCD to trigger Kubernetes to deploy the app. Within ArgoCD, this is using the Manifest from the Git repository, that has been updated with Kustomize to use the new image tag. This will then go out and deploy a new version of it, based upon the image generated by Jenkins.


# OPTIONAL

Patching the argocd-server to LoadBalancer
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'`

Patching the argocd-server to NodePort
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'`



#################
# usage in gitea: 
#################
#
# http://{server_name}.{namespace}.svc.cluster.local:{portnumber}/path/to/your/deployment/repo.git
#
# e.g. http://gitea-charts-http.default.svc.cluster.local:3000/haesun/Deployment.git
#

* Code pipeline (Source code): Opens PR for feature branch -> master branch
Secret detection, static analysis and image scanning will run in the pipeline. If it passes all the tests, update and push image into the image registry. If fails, break the pipeline.
        
<img width="676" alt="code pipeline" src="https://user-images.githubusercontent.com/58884456/124769606-f1c39e80-df7c-11eb-90ce-641d6f634aa0.png">

* GitOps pipeline (Config manifest): Opens PR for the new release manifest.
<img width="1368" alt="GitOps pipeline" src="https://user-images.githubusercontent.com/58884456/124769802-1e77b600-df7d-11eb-9eac-671ea28f4df8.png">


######################
kubelint runs towards the manifests config files.
If it passes all the tests, developer can merge the PR, otherwise the pipeline blocks the PR from merging.
        
ArgoCD is monitoring the GitOps repo. So once the PR gets merged into main branch, ArgoCD will realise the change since the Kubernetes cluster’s manifest and GitOps manifest are different.

ArgoCD will update and deploy with new GitOps Repo’s manifest. By having `argocd app wait APPNAME` step in the pipeline, it won't go to the next step until the sync is done, and once the sync is done (aka. ArgoCD deployed on Kubernetes Dev Cluster) fuzzer runs toward that live server. 
(Note that fuzzer needs (documentation, openAPI) && (Active server)  )
   
** Inside Drone CI Pipeline
        
kind: pipeline
type: docker
name: default

steps:        
- name: cd
  image: argoproj/argocd-cli
  commands:
  - argocd app wait APPNAME

- name: fuzzer
  image: owasp/zap2docker-stable
  commands:
  - blah blah
    -> Successful: Pipeline will send webhook to Gitea to notify the developer that the dynamic testing was successful.
    -> Failure: Break pipeline, ArgoCD will rollback the application to the previous deployed version by History ID. The command for this is `argocd app rollback APPNAME ID [flags]`
**

    

######################

Not our demo part but ideally in the real world, for the production cluster

Open new PR:
dev cluster -> prod cluster
######################
        


