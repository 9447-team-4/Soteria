# ArgoCD Manifests

ArgoCD manifests for the pipeline

if you are running in minikube, run
`minikube start --vm-driver=hyperkit`

create namespace 'argocd' in minikube
`kubectl create namespace argocd`

Run the following command to install ArgoCD
`kubectl apply -n argocd -f ./path/to/install.yaml`

(You can check the status by running `kubectl -n argocd get pods`. Controller looks after all the app yamls we passed in.)

If something is running in port 8080
`sudo lsof -i :8080`
`kill -9 [process id]`

Run the following command to fast forward to localhost
`kubectl port-forward svc/argocd-server -n argocd 8080:443`

Run the following command to obtain the initial admin password for ArgoCD.
(When logging into the ArgoCD server, the initial id is set to '`admin`')

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo`

You may run `kubectl apply -n argocd -f ./path/to/your/app.yaml` to test deploying a sample app I provided in Soteria, else just create one in the ArgoCD UI.

# About ArgoCD CLI
For convenience, the argocd CLI can be downloaded directly from the API server. This is useful so that the CLI used in the CI pipeline is always kept in-sync and uses argocd binary that is always compatible with the Argo CD API server.

export ARGOCD_SERVER=argocd.mycompany.com
export ARGOCD_AUTH_TOKEN=<JWT token generated from project>
curl -sSL -o /usr/local/bin/argocd https://${ARGOCD_SERVER}/download/argocd-linux-amd64

If automated synchronization is configured for the application, this step is unnecessary. 
The controller will automatically detect the new config (fast tracked using a webhook, or polled every 3 minutes), and automatically sync the new manifests.


#  ArgoCD CLI to manually sync the App

`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app sync $APP_NAME --force`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app sync test-app --force`


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app wait $APP_NAME --timeout 600`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app wait test-app --timeout 600`

The above simply asks ArgoCD to trigger Kubernetes to deploy the app. Within ArgoCD, this is using the Manifest from the Git repository, that has been updated to use the new image tag. This will then go out and deploy a new version of it, based upon the image generated by the CI.

(Optional) kubectl commands to patch argocd-server

Patching the argocd-server to LoadBalancer
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'`

Patching the argocd-server to NodePort
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'`




# Usage in Gitea

When you are trying to connect the Gitea's git repository to ArgoCD, you should use a repo url such as below.

`http://{server_name}.{namespace}.svc.cluster.local:{portnumber}/path/to/your/deployment/repo.git`

e.g. `http://gitea-charts-http.default.svc.cluster.local:3000/haesun/Deployment.git`

# Soteria's DevSecOps Pipeline
Our pipeline runs in Kubernetes.

* Code pipeline (Source code): Opens PR for feature branch -> master branch
Secret detection, static analysis and image scanning will run in the pipeline. If it passes all the tests, update and push image into the image registry. If fails, break the pipeline.
        
<img width="676" alt="code pipeline" src="https://user-images.githubusercontent.com/58884456/124769606-f1c39e80-df7c-11eb-90ce-641d6f634aa0.png">

* GitOps pipeline (Config manifest): Opens PR for the new release manifest.
<img width="1368" alt="GitOps pipeline" src="https://user-images.githubusercontent.com/58884456/124769802-1e77b600-df7d-11eb-9eac-671ea28f4df8.png">



kubelint runs towards the manifests config files.
If it passes all the tests, developer can merge the PR, otherwise the pipeline blocks the PR from merging.
        
ArgoCD is monitoring the GitOps repo. So once the PR gets merged into main branch, ArgoCD will realise the change since the Kubernetes cluster’s manifest and GitOps manifest are different.

ArgoCD will update and deploy with new GitOps Repo’s manifest. By having `argocd app wait APPNAME` step in the pipeline, it won't go to the next step until the sync is done, and once the sync is done (aka. ArgoCD deployed on Kubernetes Dev Cluster) fuzzer runs toward that live server. 
(Note that fuzzer needs (documentation, openAPI) && (Active server)  )
   
# Inside Drone CI Pipeline
```
kind: pipeline
type: docker
name: default

steps:        
- name: cd
  image: argoproj/argocd-cli
  commands:
  - argocd app wait APPNAME

- name: fuzzer
  image: owasp/zap2docker-stable
  commands:
  - blah blah
    -> Successful: Pipeline will send webhook to Gitea to notify the developer that the dynamic testing was successful.
    -> Failure: Breaks pipeline, ArgoCD will rollback the application to the previous deployed version by History ID. 
       The command for this is `argocd app rollback APPNAME ID [flags]`
```

Our demo pipeline only covers the dev cluster, but ideally in the real world, for the production cluster we will open a new PR in order to push code from dev cluster to prod cluster Kubernetes.
        


