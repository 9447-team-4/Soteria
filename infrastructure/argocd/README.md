# ArgoCD Manifests

ArgoCD manifests for the pipeline

if you are running in minikube, run
`minikube start --vm-driver=hyperkit`

create namespace 'argocd' in minikube
`kubectl create namespace argocd`

Run the following command to install ArgoCD
`kubectl apply -n argocd -f ./infrastructure/argocd/argo-cd/install.yaml`
if you are inside the argocd repo, just run
`kubectl apply -n argocd -f ./argo-cd/install.yaml`

(Can check the status by running `kubectl -n argocd get pods`)

controller looks after all the app yamls we passed in.

If something is running in port 8080
`sudo lsof -i :8080`
`kill -9 [process id]`

Run the following command to fast forward to localhost
`kubectl port-forward svc/argocd-server -n argocd 8080:443`

Run the following command to obtain the initial admin password for ArgoCD.
(When logging into the ArgoCD server, the initial id is set to '`admin`')

`kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo`

Run the following command to deploy application
e.g. `kubectl apply -n argocd -f ./infrastructure/argocd/argo-cd/app.yaml`


OPTIONAL

Patching the argocd-server to LoadBalancer
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'`

Patching the argocd-server to NodePort
`kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'`

# Trigger argocd to deploy k8s with jenkins pipeline

Install ArgoCD CLI first.

Add role in the argoCD.

Made a shell script to login through argocd cli for convenience. Run `./argocd_pwd.bash` to login to the server via argocd cli.


`$ argocd proj role create-token default jenkins-deploy-role`

Add above output token to Jenkin's gloabl credential 


# ArgoCD CLI
# Sync the App


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app sync $APP_NAME --force`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app sync test-app --force`


`ARGOCD_SERVER=$ARGOCD_SERVER argocd --grpc-web app wait $APP_NAME --timeout 600`

e.g. `ARGOCD_SERVER=localhost:8080 argocd --grpc-web app wait test-app --timeout 600`

```
Name:               hell
Project:            default
Server:             https://kubernetes.default.svc
Namespace:          default
URL:                https://localhost:8080/applications/hell
Repo:               https://github.com/blahblah
Target:             HEAD
Path:               kustomize-demo
SyncWindow:         Sync Allowed
Sync Policy:        <none>
Sync Status:        Synced to HEAD (01b965e)
Health Status:      Healthy

Operation:          Sync
Sync Revision:      01b965e397f2b6611b06e29262a55b2c0842260c
Phase:              Succeeded
Start:              2021-06-29 23:40:42 +1000 AEST
Finished:           2021-06-29 23:40:43 +1000 AEST
Duration:           1s
Message:            successfully synced (all tasks run)

GROUP  KIND        NAMESPACE  NAME             STATUS  HEALTH   HOOK  MESSAGE
       Service     default    kustomize-nginx  Synced  Healthy        service/kustomize-nginx configured
apps   Deployment  default    kustomize-nginx  Synced  Healthy        deployment.apps/kustomize-nginx configured```

The above simply asks ArgoCD to trigger Kubernetes to deploy the app. Within ArgoCD, this is using the Manifest from the Git repository, that has been updated with Kustomize to use the new image tag. This will then go out and deploy a new version of it, based upon the image generated by Jenkins.
